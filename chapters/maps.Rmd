# Map

```{r}
mp <- econDV2::Map()
```

## Geographic geoms

### Point, Line and Polygon
ggplot2 is equipped with geoms that can draw all kinds of geographic structure.

```{r}
fourPoints <- data.frame(
    x=c(2, 3, 5, 3),
    y=c(-1, 0, 6, 6)
)
geometry <- list()
geometry$ggplot <- function(){
  ggplot(
    data=fourPoints,
    mapping=aes(
      x=x, y=y
    )
  )
}
```


Points:
```{r}
geometry$points <- geometry$ggplot() + geom_point()
geometry$points 
```

Path:
```{r}
geometry$path <- geometry$ggplot() + geom_path()
geometry$path
```

Polygon
```{r}
geometry$polygon <- geometry$ggplot() + geom_polygon()
geometry$polygon
```

***

### Multipolygons

  * A school consists of many buildings

```{r}
bigArea <- data.frame(
  order=1:7,
  x=c(1, 5.5, 5.5, 1,
    7, 8, 9),
  y=c(-2, -2, 7, 7,
    8, 8 , 2),
  building=c(rep("building1", 4), rep("building2", 3)), # same school
  contour=c(rep("outer",4), rep("outer",3)) # two different buildings
)

# draw each building separately
ggplot()+geom_polygon(
  data=bigArea, 
  mapping=aes(x=x, y=y, group=building)
  )
```

  * `geom_polygon` can draw a polygon with hole(s) by using `group` and `subgroup` aesthetics, with hole(s) as a polygon inside another. 
  
    * A building with a courtyard has two contours (one for the outer contour, the other for the courtyard contour). Both contours are polygons belong to the same group, but different subgroups. 
  
```{r}
fourPoints$building="building1"
fourPoints$contour="courtyard"
fourPoints$order=8:11
bigArea |> names()
bigAreaWithHoles <-
  dplyr::bind_rows(
    bigArea,
    fourPoints
  ) |> arrange(building, order)

View(bigAreaWithHoles)

ggplot(
  data=bigAreaWithHoles
) + 
  geom_polygon(
    aes(
      x=x, y=y, 
      group=building, 
      subgroup=contour
    )
  )
```

### Fill polygons

  * You can give different polygons different fills. 

```{r}
ggplot(
  data=bigAreaWithHoles
) + 
  geom_polygon(
    aes(
      x=x, y=y, 
      group=building, 
      subgroup=contour,
      fill=building
    )
  )

```


### Application to world map

We apply those `geoms` to draw some maps.

```{r}
world = ggplot2::map_data("world")
```

  * `group` column is for `group` aesthetics for polygon.

```{r world0}
world0 <- function(color="black", fill="white", size=0.35) {
  ggplot() + geom_polygon(
    data=world,
    aes(
      x=long, y=lat,
      group=group
    ),
  color=color, fill=fill, size=size
  )
}
```


```{r}
# Cartesian crs
world0()
# Cartesian with fixed aspect ratio
world0() + coord_fixed()
# Mercator projection: fixed asp, correct direction
world0() + coord_map()
# Mercator projection: fixed asp, correct direction, expand xlim
world0() + coord_map(xlim = c(-180,180))
```

## Choropleth map

  * A map with different **fill**s to show certain social-economic data variation. 

### Backgroup fill and borders

Though ggplot2 has geom function to work on Choropleth graph directly, I recommend to lay out a background map first.

Map data
```{r}
world = ggplot2::map_data("world")
```

Backgroup map base on Economist style:
```{r}
world0_background <- function(){
  world0(
    color="white", 
    fill="#c8c5be", 
    size=0.15)
}
```

### Choropleth layer: value layer

Another layer of `geom_polygon`s but with different fills setup based on social-economic data. Instead of using `geom_polygon` as the background layer does, `geom_map` is an easier to use geom for Choropleth graph. 

  * `geom_map` is a wrapper of `geom_polygon` but with a much easier setup for Choropleth map purpose.

  * use `geom_map()+expand_limits()`

```{r}
geom_map(
  data=`social-economic data`,
  mapping = aes(
    map_id = ...,
    fill = ...
  ),
  map =`map data`
)+
expand_limits(
  x=`map data`$long, y=`map data`$lat
)
```

  * `map data` from  `ggplot2::map_data` (can be filtered if needed)
  
  * `social-economic data`: a data frame with a column for `map_id` and a column for `fill`.
  
    * `map_id` column must consist of the levels of `map data`'s region column.
    
    * `fill` column: the social-economic data to show.

#### WDI example


Social-economic data
```{r}
se_data <- jsonlite::fromJSON(
  "https://www.dropbox.com/s/78jr6g6xtjz453b/women_in_parliament.json?dl=1"
)
View(se_data)
```

```{r}
world0_background() +
  geom_map(
    data=se_data,
    mapping=aes(
      map_id=country,
      fill=women_in_parliament
    ),
    map=world
  )
```

***

Fixed country name inconsistency between `se_data` and `world` data.

```{r}
se_data |> 
  mp$choropleth$rename_valueData_countryname(
  countryColumnName = "country",
  pattern = c(
    "Russia"="Russian Federation",
    "USA"="United States",
    "Iran"="Iran, Islamic Rep.",
    "Egypt"="Egypt, Arab Rep.",
    "Syria"="Syrian Arab Republic",
    "Yemen"="Yemen, Rep.",
    "UK"="United Kingdom",
    "Democratic Republic of the Congo"="Congo, Dem. Rep.",
    "Republic of Congo"="Congo, Rep.",
    "Ivory Coast"="Cote d'Ivoire",
    "Venezuela"="Venezuela, RB"
    )
  ) -> se_data

world0_background() +
  geom_map(
    data=se_data,
    mapping=aes(
      map_id=country,
      fill=women_in_parliament
    ),
    map=world
  )
```

```{r}
choropleth0 <- function(){
  world0_background() +
  geom_map(
    data=se_data,
    mapping=aes(
      map_id=country,
      fill=women_in_parliament
    ),
    map=world
  )
}
choropleth0()
```


### Fill colors

#### Sequential color

  * Color is to signal one direction strength. 
  
  * Gradient: Good for spot the highest and the lowest. Not easy to compare neighbors

Adjust fill limits-values mapping:
```{r}
# reverse fill high-low value
choropleth0() +
  scale_fill_gradient(
    high = "#132B43",
    low = "#56B1F7",
    na.value="#919191"
  )
```


```{r}
# use binned fill
choropleth0() +
  scale_fill_binned(
    high = "#003870",
    low = "#d3e3f3",
    na.value="#919191",
    guide=guide_colorbar(
      reverse = FALSE,
      label.vjust = 0.5
    )
  )
```


```{r}
scales::colour_ramp(
  c(high = "#003870",
    low = "#d3e3f3")
) -> binPalette
scales::show_col(
  binPalette(c(0, 0.5, 0.8, 1))
)

```


#### Ordered Factor

```{r}
se_data2 <- se_data
se_data2$women_in_parliament |>
  cut(c(0,20,40,60,100), ordered_result = T) -> .fct
.fct |> class()
levels(.fct) <- c("0-20%","20-40%","40-60%","60-100%")
.fct -> se_data2$women_in_parliament
```

***


```{r}
myPalette <- 
  scales::colour_ramp(
    c(low = "#d3e3f3", high = "#003870")
  )
scales::show_col(
  myPalette(c(0, 0.33, 0.66, 1))
)
```


```{r}
choropleth1 <- function(){
  world0_background() +
  geom_map(
    data=se_data2,
    mapping=aes(
      map_id=country,
      fill=women_in_parliament
    ),
    map=world
  )
}
```


```{r}
choropleth1() +
  scale_fill_manual(
    limits = c(NA, '0-20%','20-40%','40-60%','60-100%'),
    values = c("#919191", myPalette(c(0, 0.33, 0.66, 1)))
  )+
  guides(
    fill=guide_legend(
      reverse = T
    )
  )
```

```{r}
choropleth1() +
  mp$scales$scale_fill_ordered_factor(
    .ordered_fct=se_data2$women_in_parliament,
    high = "#003870", low= "#d3e3f3", na.value="#919191"
    ) +
  guides(
    fill=guide_legend(
      reverse = T
    )
  )  
```



#### Diverging color

##### colorspace {-}
Diverging color 
When dealing with diverging color it is better to rescale your color mapping source data to [-1, 1].

```{r}
se_data$women_in_parliament |>
  scales::rescale(
    from=c(0, 100), 
    to=c(-1, 1)
  ) -> se_data$women_in_parliament
```


colorspace package:
```{r}
## Register custom color palette
colorspace::diverging_hcl(n = 7, h = c(255, 12), c = c(50, 80), l = c(20, 97), power = c(1, 1.3),  register = "man_woman")

choropleth0() +
colorspace::scale_fill_binned_diverging(
  labels = function(x) (x+1)*50,
  palette="man_woman"
)
```

##### scale with 2 direction fill/color

```{r} 
choropleth0()+
scale_fill_steps2(
  breaks=c(-0.85, -0.65, -0.35, -0.15, 1.5),
  high = scales::muted("red"),
  mid = "#d6ffe6",
  low = "#0a23ff",
  midpoint = 0,
  na.value = "#d9d9d9"
)
```

## Map as background

### ggmap

Two steps:

  1. `get_xxxmap` to obtain raster map image.
  
  2. `ggmap` to produce a gg(plot) object as a background layer.
  
```{r}
mp$prepare_dataframe_from$map()
```


## Simple feature

```{r}
install.packages("sf")
```

  * <https://r-spatial.github.io/sf/>

Another type of geographic data structure. 

  * a new class. Each value in a simple feature vector represents a form of geometry (called **feature**) and its geographic notation (i.e. latitude and longitude); and could carry its coordinate reference system.
  
  * Each value is a parsing result from `sf::st_xxx` functions where `xxx` can be `point` (台北大學的一個地標，如[YouBike站](https://www.google.com.tw/maps/place/YouBike+1.0/@24.9425965,121.3700117,18z/data=!4m5!3m4!1s0x34681b7d1f8d8569:0x5d135a3058409b3e!8m2!3d24.94317!4d121.36952)), `multipoint` (台北大學所有地標), `linestring`(台北大學的一條路徑), `polygon`(台北大學的一棟建築), `multilinestring`(台北大學的所有路徑), `multipolygon`(台北大學的所有建築), or `geometrycollection`(整個台北大學)

```{r, echo=F}
source("support/maps.R")
```

### Define simple features

A simple feature is composed of numeric vector, matrix, or list. No data frame is used. 


```{r}
geoValues <- list()
geoValues$simple_feature$point <-
  sf::st_point(
    c(24.9433123, 121.3699526)
  )
geoValues$simple_feature$multipoint <-
  sf::st_multipoint(
    rbind( # will form a matrix
      c(24.9443019, 121.3714944), # 1st point
      c(24.9440709, 121.3728518) # 2nd point
    )
  )
geoValues$simple_feature$linestring <-
  sf::st_linestring(
    rbind(
      c(24.9423755, 121.3679438), # 1st trace point
      c(24.9429941, 121.3679432), # 2nd trace point
      c(24.9432087, 121.3686713) # 3rd trace point
    )
  )
geoValues$simple_feature$polygon <-
  sf::st_polygon(
    list(
      # 1st closed trace
      rbind(
        c(24.9441895, 121.3695181),
        c(24.9442244, 121.3692544),
        c(24.9437158, 121.3694094),
        c(24.9438647, 121.3696271),
        c(24.9441895, 121.3695181) # close the polygon
      )
    )
  )
# polygon: a list consists of matrices.
```

```{r}
class(geoValues$simple_feature$point)
class(geoValues$simple_feature$linestring)
class(geoValues$simple_feature$polygon)
# all have sfg class
```

Simple feature value can be graphed directly via `geom_sf()`
```{r}
geoValues$simple_feature$polygon |> ggplot()+geom_sf()
```

### Form simple feature column

A collection column of multiple simple features.

```{r}
sf::st_sfc(geoValues$simple_feature) -> geoValues$simple_feature_column

class(geoValues$simple_feature_column) # "sfc_GEOMETRY" "sfc" 
# has class sfc
```

```{r}
geoValues$simple_feature_column |> 
  ggplot()+geom_sf()
```


### Form simple feature data frame

  * A simple feature data frame is basically a data frame with a column named **geometry** which is a list of each obervation's simple feature value.

```{r}
# initiate a data frame
df_sf <- data.frame(
  name=c("landmark 1", "must-see landmarks", "path 1", "building 1")
)

# add simple feature column
df_sf |> sf::st_set_geometry(geoValues$simple_feature_column) ->
  geoValues$simple_feature_df

class(df_sf) # only "data frame"
df_sf |>
  dplyr::mutate(
    geometry=geoValues$simple_feature_column
  ) -> df_sf2
class(df_sf2) # still a "data frame"
# Must go through sf::st_set_geometry to get sf class
class(geoValues$simple_feature_df) # "sf" "data.frame"

geoValues$simple_feature_df |> ggplot()+geom_sf()
```

## Import Simple Feature Data

  * <https://tpemartin.github.io/economic-data-visualization/zh-tw/annotation-and-maps.html#%E8%AE%80%E5%85%A5shp%E6%AA%94>

## Projection

#### Mercator projection

Standard longitude and latitude system when laid out on the Cartesian plane will be a standard Mercator tanget projection with no rotation with center point the mean of data longitudes and latitudes (roughly `(0,0)`). 

<figure>
```{r, echo=F, eval=TRUE}
teachDS::img_centering(
  "https://upload.wikimedia.org/wikipedia/commons/b/b5/Comparison_of_Mercator_projections.svg"
)
```
<figcaption>Mercator projection</figcaption>
</figure>

To gain more control on projection result, use `coord_map()`:
```{r}
world0() + coord_map()
```

<div class="alert alert-warning">
By default, `coord_map()` take `xlim=range(world$long)`, range has some round off effect which cuts the true range short, creating the erraneous connection problem. To avoid that, set `xlim=c(-180, 180)` (a little wider than the range rendered).
```{r}
world0() + coord_map(xlim=c(-180, 180))
```

</div>

Set orientation vector:  
> A vector c(latitude,longitude,rotation) which describes where the "North Pole" should be when computing the projection.

```{r}
center_longitude = 90 #input$center_longitude
rotation = 0 #input$rotation
mapproj::mapproject(
  world$long,
  world$lat,
  projection="mercator",
  orientation = c(90, center_longitude, rotation)
) -> longlat_new
world_new <- data.frame(
  longlat_new[c("x","y")]
)
world_new$group <- world$group
```

```{r}
world <- world |> dplyr::filter(region !="Antarctica", is.na(subregion))
```

```{r}
center_longitude = 0 #input$center_longitude
rotation = 0 #input$rotation
```


```{r}
world = ggplot2::map_data("world")
world0()+coord_map(
  # xlim=c(-180, 180),
  orientation = c(90, 0, rotation),
  clip="off"
)+
  expand_limits(x=range(world$long), y=range(world$lat))
```

```{r}
world |> group_by(region) |> 
  slice(1) -> world_value
ggplot()+
  geom_map(
    data=world_value,
    aes(map_id=region),
    fill="white", color="black",
    map=world
  ) 
```


```{r}
gg0+coord_map(
  clip="off"
)
gg0+coord_map(
  xlim= c(-190, 190)
)
(gg0 + coord_map()) |>
  plotly::ggplotly()
gg0 + coord_quickmap()
mean(range(world$long))
o1 = 90 #input$o1
o2 = 0 #input$o2
o3 = 5.1354 #input$o3
gg0+coord_map(
  orientation=c(o1, o2, o3)
)
gg0 + coord_quickmap(
  orientation=c(o1, o2, o3)
)
last_plot() + coord_map(projection = "sinusoidal")
last_plot() + coord_map(
  orientation = 
)
```

### Various projection

![cylindrical projection](https://support.esri.com/~/media/Support/GISDictionary/cylindrical-projection.jpg)
Types of cylindrical map projections you may know include the popular Mercator projection, Cassini, Gauss-Kruger, Miller, Behrmann, Hobo-Dyer, and Gall-Peters.





![planar projection](https://support.esri.com/~/media/Support/GISDictionary/planar-projection.jpg)


***

You can pull out certain country data via filter on `region`.

  * A country can have many polygons defined by `subregion`, like Taiwan.

```{r}
world |> 
  dplyr::filter(
    stringr::str_detect(region, "Taiwan")
  ) ->
  taiwan

taiwan |> 
  ggplot() + geom_polygon(
    mapping=aes(
      x=long, y=lat, group=group
    )
  )

last_plot() + coord_map()
```

  * By default, all geom (except geom_sf) is graphed based on Cartesian coordinate system. You need to `+coord_map()` to do map projection.
  
```{r}
# the default of coord_map
coord_map(
  projection = "mercator",
  ...,
  parameters = NULL,
  orientation = NULL,
  xlim = NULL,
  ylim = NULL,
  clip = "on"
)
```
  

  * If multiple coordinate systems are detected, the last coordinate system will be used.


## Rotate the projection 

<!--

## Map overlay


```{r}
xfun::download_file("https://www.dropbox.com/s/kvjpd1idvsln41k/20-Mar-2021-sanxiaBikeRoute.gpx?dl=1")
econDV2::Object(bikeRoute)
bikeRoute$data$raw <- 
  plotKML::readGPX(
    gpx.file="20-Mar-2021-sanxiaBikeRoute.gpx")
bikeRoute$data$track <-
  bikeRoute$data$raw$tracks[[1]][[1]]
```

```{r}
ggplot() +
  geom_path(
    data=bikeRoute$data$track,
    mapping=
      aes(
        x=lon,
        y=lat
      )
  ) + coord_map()
```

### Raster image

```{r}
mp$browse$openstreetmap()
```


```{r}
mp$copy_paste$osm_bbox()
```
left=121.3512,
bottom=24.9435,
right=121.3849,
top=24.9615


```{r}
img <- list()
xfun::download_file("https://www.dropbox.com/s/e2kct9xropvg1h5/map_sanxia.png?dl=1")
magick::image_read("map_sanxia.png") -> img$raw
magick::image_resize(
  img$raw,
  geometry = magick::geometry_size_percent(width = 50, height = NULL)
) -> img$resize

magick::image_flatten(
  img$raw
) -> img$flatten

magick::image_write(
  img$resize, path="map_resize.png"
)
```

```{r}
check_size <- function(x){
  x |> magick::image_raster() |>
    pryr::object_size()
}
```

```{r}
raster_0 <- magick::image_raster(
  img$raw
)
pryr::object_size(raster_0)

raster_map <- magick::image_raster(img$resize)
pryr::object_size(raster_map)
raster_flatmap <- 
  magick::image_raster(img$flatten)
pryr::object_size(raster_flatmap)


img$raw |> check_size()

img$raw |>
  magick::image_quantize(colorspace="gray") |> 
  check_size()

img$raw |> 
  magick::image_quantize(
    max=30,
    colorspace = "gray") |> #print()
  check_size()

img$raw |> 
  magick::image_quantize(
    max=30,
    colorspace = "gray") |>
  magick::image_resize(
    geometry = magick::geometry_size_percent(80)
  ) |> #print()
  check_size()

img$raw |> 
  magick::image_quantize(
    max=30,
    colorspace = "gray") |>
  magick::image_resize(
    geometry = magick::geometry_size_percent(80)
  ) |>
  magick::image_raster() -> img$resize_gray
```

```{r}
img$resize_gray$col |> unique() -> colorlimit
ggplot()+
  geom_raster(
    data=img$resize_gray,
    mapping=aes(
      x=x, y=y, fill=col
    )
  )+
  scale_fill_manual(
    limits = colorlimit,
    values = colorlimit
  )+
  theme(
    legend.position = "none"
  )-> gg1

gg1
```


```{r}
econDV2::Object(overlay)
overlay$raster$google <- {
  ggmap::get_map(
  c(lon=121.3684249, lat=24.9521791),
  zoom=15)
}
overlay$raster$statmen <- {
  
}
overlay$raster$osm <- {
  ggmap::get_map(
    c(left=121.34759,
bottom=24.94224,
right=121.38503,
top=24.96071),
    source="osm"
  )
}
```


```{r}
attach(bikeRoute$data)
{
  track[c("lon", "lat")] |> as.matrix() |> sf::st_linestring() -> track_linestring
  
  track_linestring |> sf::st_crs()
  
  ggplot()+geom_sf(data=track_linestring, crs=NULL)
  
  ggmap::get_map(
c(lon=121.3684249, lat=24.9521791),
zoom=15  ) -> raster_ntpu
  
  
  ggmap(raster_ntpu) -> gg_ntpu
  
  gg_ntpu |> sf::st_crs()
  raster_ntpu |> sf::st_crs()
  track_linestring |> sf::st_crs()
  
  gg_ntpu + geom_sf(
    data=track_linestring,
    inherit.aes = F
  )+theme_void()

  # gg_ntpu and geom_sf are two different coordinate systems by concepts. Here both has no crs setting. So the warning is wrong.
}
detach(bikeRoute$data)
```

```{r}
us <- c(left = -125, bottom = 25.75, right = -67, top = 49)
get_stamenmap(us, zoom = 5, maptype = "toner-lite") |> ggmap() 
```


## Raster map 

```{r}

us <- c(left = -125, bottom = 25.75, right = -67, top = 49)
bbox_ntpu <- 
  c(top=24.94709,
right=121.37619,
bottom=24.93842,
left=121.36230)
ggmap::get_map(
  location= c(lon=121.37015,lat=24.94311),
  source="osm"
)
ggmap::get_openstreetmap(
  bbox=bbox_ntpu
) -> map_ntpu 
get_stamenmap(us, zoom = 5, maptype = "toner-lite") %>% ggmap()  -> gg0
```


24.94709 (top)
121.37619 (right)
24.93842
121.36230



```{r}
magick::image_read("/Users/martinl/Downloads/map_ntpu.png") -> map_ntpu
magick::image_raster(map_ntpu) -> raster_ntpu
pryr::object_size(raster_ntpu) # extremely big
```

  * **Raster** is not an efficient way to store image information. 
  
```{r}
newTaipeiBBox <- c(xmin=121.28263, ymin=24.67316, xmax=122.00640, ymax=25.29974)
```


## open street map (OSM)

  * <https://openstreetmap.org>

```{r}
browseURL("https://openstreetmap.org")
```

## ggmap

```{r}
ggmap::get_openstreetmap(
  
)
```


```{r}
library("ggmap")
#  Loading required package: ggplot2
#  Registered S3 methods overwritten by 'ggplot2':
#    method         from 
#    [.quosures     rlang
#    c.quosures     rlang
#    print.quosures rlang
#  Google's Terms of Service: https://cloud.google.com/maps-platform/terms/.
#  Please cite ggmap if you use it! See citation("ggmap") for details.

us <- c(left = -125, bottom = 25.75, right = -67, top = 49)
get_stamenmap(us, zoom = 5, maptype = "toner-lite") %>% ggmap()  -> gg0
gg0 |> class()
gg0$data
ggmap |> body() |> clipr::write_clip()
```

-->